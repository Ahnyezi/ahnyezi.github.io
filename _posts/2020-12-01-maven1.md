---
title:  "[Maven ①] 프로세스 동기화와 상호배제"
date: 2020-12-01
categories: ['Maven']
tags: ['Maven']
---

[Operating System ⑥] 프로세스 동기화와 상호배제


프로세스 동기화와 상호배제


##### HPC Lab 김덕수 교수님의 운영체제 강의를 정리한 내용입니다. :+1: 
[강의링크](https://www.youtube.com/watch?v=wdaf2gy83uU&list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&index=12)

<br>

### 목차



:point_right: **[1] 프로세스 동기화와 상호배제** <br>

1.  [동기화란](#1-a-동기화란)

2.  [비동기와 병행](#1-b-비동기와-병행)

3.  [관련용어](#1-c-관련용어)

4.  [상호배제](#1-d-상호배제)

5.  [상호배제의 방법들](#1-e-상호배제의-방법들)

6.  [상호배제 프리미티브가 만족해야하는 조건들](#1-f-상호배제-프리미티브가-만족해야하는-조건들)

7.  [두 프로세스의 상호 배제](#1-g-두-프로세스의-상호-배제)

<br><br>



## :pushpin: 메이븐(Maven)이란?

### 1-A. Maven이란

**프로젝트 빌드 과정은 다음과 같은 단계를 거친다.** <br>
1. `프로젝트 생성`
2. `라이브러리 설정`
3. `코드 작업`
4. `컴파일`
5. `테스트`
6. `패키지 생성`
7. `배포`
8. `레포팅(문서 작성)`
<br>

**이와 같은 빌드 과정에서 일어날 수 있는 일들을 좀 더 효율적으로 관리할 수 있게 도와주는 도구를 `빌드 도구`라 하며, `Maven`은 이러한 빌드 도구의 일종이다.** 

<br>

### 1-B. IDE와 빌드도구

우리는 흔히 `Eclipse`나 `Intellij` 또는 `Visual Studio`를 사용하여, 프로젝트를 생성/관리한다. <br>
그럼 이것도 **빌드툴**이라 볼 수 있을까?<br>
**Nope!**<br>
<br>

`Eclipse`, `Intellij` , `Visual Studio`은 **통합개발환경(Integrated Development Environment)**에 속한다. **IDE**는 더 많은 툴들을 결합시켜 만든 **빌드툴보다 더 큰 단위의 개념**으로 볼 수 있다. <br>
- `예시` maven은 단순히 빌드를 도와주는 기능을 하지만, IDE는 코드를 수정하거나 협업하는 등 빌드기능 이외의 다양한 기능을 제공한다. <br>
<br>

:notebook: **Reference**
**소프트웨어 빌드란?**
**소스코드파일**을 컴퓨터에서 실행할 수 있는 **독립 소프트웨어 가공물로 변환**하는 과정이다.<br>

:point_right: **대표적인 빌드 과정**<br>
-  `compile`:  개발자가 작성한 소스코드를 바이너리 코드로 변환하는 과정.
   - 소스파일을 컴퓨터가 이해할 수 있는 기계어(저급언어)로 번역
   - 목적파일(.obj)이 생성됨
   - `예시`: Java는 JVM에서 실행가능한 바이트코드 형태의 클래스파일(.class)가 생성된다.
- `link`: 여러 개의 목적파일을 하나로 묶어 실행파일을 생성.
   - 최종 실행파일(.exe)이 생성됨
   - `예시`: 프로젝트가 A,B,C...등 여러개의 소스파일로 구성된 경우. 소스파일을 각각 컴파일하면 A가 B에 존재하는 함수를 찾지 못하기 때문에 호출할 수 없다. 따라서, 여러개로 분리된 소스파일들에서 필요한 부분을 찾아 서로 연결해주는 작업이다. 

이 두 과정을 합쳐 **Build**라 부른다.<br>

:point_right: **빌드툴**<br>
대표적인 빌드툴은 `Ant`, `Maven`,`Gradle`이 있으며<br>
전처리(preprocessing), 컴파일(compile), 패키징(packaging), 테스팅(testing), 배포(distribution) 등의 기능을 제공한다.

<br>

:point_right: **IDE가 있는 데 왜 빌드툴을 사용하는가?**<br>
maven등의 빌드툴을 사용해서 프로젝트를 생성하는 것이 더 생산성 좋은 경우가 있다. <br>

<br>
<br>



## :pushpin: 메이븐 설치

**maven**은 apache에서 제공하는 프로젝트의 일종이다. apache사이트에 들어가서 maven을 설치해보자.<br>

> 압축파일 다운로드 <br>

Binary zip archive <br>

<img src="https://user-images.githubusercontent.com/62331803/100706510-7c8f5a00-33ec-11eb-8e7e-60b0de7a4ed6.png" width="50%"><br>
<br>

> 실행할 파일 확인<br>

실행하고자 하는 파일은 bin(arny)폴더의 mvn파일이다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100707619-47840700-33ee-11eb-8077-14235c28cf97.png" width="50%"><br>
<br>

> 콘솔을 통해서 파일을 실행한다<br>

mvn파일을 실행하기 위해서는, 해당 바이너리 파일이 존재하는 `bin` 폴더로 이동해야 한다. <br>
파일을 실행할 때마다 해당 폴더를 이동해야하는 번거로움을 없애기 위해서,  maven의 경로를 **path**라는 환경변수를 등록해줄 수 있다. <br>
<br>

:notebook: **Reference | path란?**<br>

console창에 `path`를 입력하게 되면, 현재 컴퓨터에 등록된 모든 `path`목록을 띄워준다. <br>
**이 path는 무슨 의미일까?**

콘솔창에 기존에 등록지 않은 명령어를 콘솔에 입력할 경우, 다음과 같은 오류 메세지가 띄워진다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100708503-c7f73780-33ef-11eb-938f-cc2fefceecea.png" width="80%"><br>

**cmd로 부터 받은 명령어를 처리되는 과정을 살펴보면 다음과 같다.**<br>
- 명령어가 입력되고 
- 해당 명령어가 Dos가 가진 내부명령인지를 확인하고
-  예약된 디렉토리의 외부 명령인지를 확인하고
- path에 존재하는 각 디렉토리를 확인하여 실행할 수 있는 프로그램/파일인지를 확인하는 과정을 거치게 된다. 
- 그리고 어떠한 파일도 찾을 수 없는 경우에는 다음과 같은 오류 메세지가 출력되는 것이다. 

즉 `path`는 우리가 콘솔로부터 어떠한 명령을 할 경우, 전체경로를 쓰지 않아도 우리가 원하는 프로그램/파일을 실행할 수 있도록 미리 등록해 놓은 경로를 의미한다. <br>
<br>

> path 등록<br>

maven 디렉토리의 경로를 환경변수로 등록한다. <br>

- 환경변수명 : `M2_HOME`<br>

<img src="https://user-images.githubusercontent.com/62331803/100709757-0130a700-33f2-11eb-9440-be2aedb0e459.png" width="80%"><br>


- 등록 완료<br>

<img src="https://user-images.githubusercontent.com/62331803/100709885-33420900-33f2-11eb-8f6a-a8cfb830a068.png" width="80%"><br>

- 환경변수 `M2_HOME` 으로 새로운 환경변수인 `%M2_HOME%bin` 생성 <br>

<img src="https://user-images.githubusercontent.com/62331803/100709985-61274d80-33f2-11eb-8834-0a5c83a5a755.png" width="80%"><br>

`%path_name%`이란, 다른 path를 참조한 path를 등록할 수 있도록 하는 연산자이다. <br>

- 메이븐 설치 확인<br>

<img src="https://user-images.githubusercontent.com/62331803/100731442-ba04df00-340e-11eb-8e72-22dae7849708.png" width="80%"><br>
<br>
<br>

## :pushpin: Maven(메이븐)으로 자바 프로젝트 생성하기

우리는 **Maven**을 사용해서 `프로젝트를 생성`하거나, `생성된 소스코드를 컴파일`하거나, `라이브러리를 설정`하는 등의 작업을 간편하게 할 수 있다.  <br>
그렇다면, 실제 위와 같은 기능을 사용하기 위해 **우선 자바 프로젝트를 만들어보자.**<br>
<br>

> 자바 프로젝트 생성하기 <br>

**cmd 콘솔에 명령어를 입력하여 손쉽게 프로젝트를 생성할 수 있다.** <br>
자바 프로젝트 생성을 위한 명령어를 살펴보자. <br>

<img src="https://user-images.githubusercontent.com/62331803/100734000-5a103780-3412-11eb-99fc-845c989d136d.png" width="100%"><br>

`
mvn archetype:generate -DgroupId=com.newlecture -DartifactId=javaprj -DarchetypeArtifactId=maven-archetype-quickstart
`


:point_right: **명령어 해석**<br>

- `-D`: 구분자
- `archetype:generate`: **archetype**을 만들어라
   - 이클립스를 사용하여 자바 프로젝트를 생성할 경우, 매번 새 도화지에 그림을 그려야 하는 것과 같이 처음부터 다시 만들어야 한다. 
   - Maven을 사용하여 자바 프로젝트를 생성할 경우, 아키텍처(프로젝트 구조/형식)파일을 템플릿처럼 사용하여 프로젝트를 만들 수 있다. 
   - 다른 사람이 만들어 놓은 프로젝트를 사용할 수도 있고, 내가 만든 프로젝트 형태를 배포할 수도 있다. 

- `archetypeArtifactId=maven-archetpe-quickstart`: **quickstart**템플릿을 사용하겠다.
   - quickstart는 자바 개발시 사용되는 기본 템플릿 중 하나다.

- `artifactId=javaprj`: 프로젝트 이름은 **javaprj**로 하겠다. 
   - 내가 만든 프로젝트 아키텍트를 배포하여 다음 번에 또 사용하게 한다면, 이 아이디가 아키텍트 아이디가 될 것이다. 

- `groupId=com.newlecture` : 그룹id는 **com.newlecture**로 하겠다.

   - 프로젝트명이 충돌나는 것을 방지하기 위해 그룹id를 설정한다. 
   - id이름은 패키지명과 비슷하게 설정한다
   - 보통 자신만의 도메인 이름을 사용하면서 더 큰 범위부터 뒤집어서 사용한다. 
   - `newlecture.com`을 역순으로 쓴 `com.newlecture`를 사용
<br>

**정상적으로 설치가 완료되면, 다음과 같은 구조를 가진 프로젝트가 만들어진다.** <br>
<img src="https://user-images.githubusercontent.com/62331803/100734848-a3ad5200-3413-11eb-90ee-288be1939b7b.png" width="60%"><br>
<br>

> 설치 완료 <br>

- Build Success 문구가 뜨면, 프로젝트가 설치된 디렉토리를 확인해보자.
- `javaprj` 디렉토리가 생성된 것을 확인 할 수 있다. 

<img src="https://user-images.githubusercontent.com/62331803/100733475-98f1bd80-3411-11eb-993c-758ff41f4393.png" width="60%"><br>
<br>

 - `src\main\java\com\newlecture`디렉토리 안을 확인하면, `App.java` 파일을 확인할 수 있다. 

**src\main\java\com\newlecture**<br>

<img src="https://user-images.githubusercontent.com/62331803/100733623-cb9bb600-3411-11eb-82f8-ce73f15ebcd3.png" width="80%"><br>

**App.java**<br>

<img src="https://user-images.githubusercontent.com/62331803/100733678-dfdfb300-3411-11eb-8413-9cee2405ad82.png" width="80%"><br>
<br>
<br>

## :pushpin: Maven(메이븐) 프로젝트 컴파일과 실행

이번에는 **IDE** 없이 **Maven**을 이용하여 `컴파일`과 `실행`을 해보자!<br>
<br>

우선 저번 시간에 **Maven**으로 생성한 `javaprj`디렉토리를 살펴보자. Root 디렉토리에는 항상 `pom.xml`파일이 존재한다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100742137-a14ff580-341d-11eb-847f-9e4eceec6e33.png" width="70%"><br>

**`소스코드 컴파일`, `실행` 등 Maven 관련 명령어를 실행할 때는, 항상 `pom.xml`파일이 있는 루트 디렉토리에서 실행해야 한다!**<br>
<br>

**컴파일과 실행을 위해 우선 소스코드를 편집해보자.** <br>
<br>

### 소스코드 편집과 실행과정

> 소스코드 편집<br>

<img src="https://user-images.githubusercontent.com/62331803/100742488-3652ee80-341e-11eb-9c88-bd00a527ed90.png" width="70%"><br>
<br>

> 컴파일<br>

Root 디렉토리위치에서 `mvn compile`을 실행한다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100742703-90ec4a80-341e-11eb-87e6-54b926f1236a.png" width="100%"><br>
<br>

:notebook: **Error**<br>

1. **선생님 강의 중 발생한 error**

- 컴파일러 옵션을 바꾸라는 에러<br>
<img src="https://user-images.githubusercontent.com/62331803/100743009-0526ee00-341f-11eb-8441-05a812534fb8.png" width="100%"><br>

- 해결방법 : `pom.xml`에 다음과 같은 코드를 추가한다. <br>

```xml
 <properties>
	<maven.compiler.source>1.8</maven.compiler.source>
	<maven.compiler.target>1.8</maven.compiler.target>
  </properties>
```

   - `<maven.compiler.source>1.8</maven.compiler.source>`: 1.8버전으로 컴파일 되게 해라
    - `<maven.compiler.target>1.8</maven.compiler.target>`: 1.8이상에서 수행되도록 컴파일 해라


- 수정 이후 다시 컴파일하면 Build 성공

<img src="https://user-images.githubusercontent.com/62331803/100738888-a27f2380-3419-11eb-95c8-3e7e110aafca.png" width="100%"><br>
<br>


> 컴파일 결과 확인<br>

**`javaprj\target`디렉토리
에 자바 소스파일을 컴파일한 결과인 .class 파일이 만들어진 것을 확인할 수 있다.**<br>

<img src="https://user-images.githubusercontent.com/62331803/100739118-fab62580-3419-11eb-806a-0d1295db640a.png" width="90%"><br>
<br>

> 프로젝트를 패키지화해보자<br>

`mvn package` 명령을 통해 패키지(.jar 파일)를 만들 수 있다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100743918-508dcc00-3420-11eb-9d9c-a1350ae26fdc.png" width="100%"><br>
<br>

> 결과확인<br>

`SNAPSHOT1.0`버전으로 패키지 생성완료되었다.<br>

<img src="https://user-images.githubusercontent.com/62331803/100739332-47016580-341a-11eb-8a7f-d38f8b18a28b.png" width="100%"><br>
<br>

> 실행 <br>

**컴파일된 클래스 파일을 실행할 수 있는 방법은 2가지이다.** 

1. `classes` 디렉토리 안의 App.class파일을 직접 실행
2. `target` 디렉토리 안의 .jar 배포파일을 통해 실행
<br>

:point_right: **그럼 (방법2) 패키지화 된 .jar 파일을 통해 실행하는 방법을 알아보자.** <br>

`.jar`파일은 확장자가 `.jar`인 압축파일이다. <br>
잠시 확장자를 `.zip`으로 바꿔서 안을 들여다보면, 압축된 형태일 뿐 자바 프로젝트와 내용물이 동일한 것을 알 수 있다.<br>
즉, 이 `.jar`파일을 이용해서 해당 파일 안에 있는 클래스 파일을 실행시키면 되는 것이다. <br>

<img src="https://user-images.githubusercontent.com/62331803/100739570-99428680-341a-11eb-8d25-90ef920d7c1e.png" width="100%"><br>
<br>



**이제 배포파일을 실행해보자**<br>

명령어는 다음과 같다. <br>

`java -cp target\javaprj-1.0-SNAPSHOT.jar com.newlecture.App`


:point_right: **명령어 해석**<br>

- `com.newlecture.App`: 실행하고자 하는 클래스 파일 이름
- `cp(class path)`: 클래스 파일이 위치한 경로를 지정하기 위한 명령어
- `target\javaprj-1.0-SNAPSHOT.jar` : 실행할 파일이 위치한 실제 경로

즉  `java`를 이용하여 `com.newlecture.App`파일의 main함수를 실행할 것이고,
해당 파일이 사용하고 있는 라이브러리가 존재하는 `target\javaprj-1.0-SNAPSHOT.jar` 를 classpath로 지정하여 클래스를 실행하겠다. 
<br>
<br>

**실행한 결과는 다음과 같다.** <br>

<img src="https://user-images.githubusercontent.com/62331803/100745527-c135e800-3422-11eb-8729-dc58c9142f46.png" width="100%"><br>

내가 편집한 내용이 제대로 찍힌다! <br>
<br>
