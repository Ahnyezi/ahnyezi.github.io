---
title:  "백준 9465 스티커 파이썬"
date: 2020-11-28
categories: ['Algorithm']
tags: ['DP','스티커']
---

boj 9465 스티커

<br>

[문제링크](https://www.acmicpc.net/problem/9465)

<br>

:bulb: **풀이**<br>

**테스트 케이스를 직접 그려보면서 규칙을 찾았다.**<br>

<img src="https://user-images.githubusercontent.com/62331803/100489084-8d726e00-3155-11eb-879c-157f89548c94.png" width="40%">
<br>

다음과 같은 스티커판이 주어졌을 때,<br>
상하좌우를 사용할 수 없다는 조건을 단순하게 적용하여<br>
**0열을 제외한 모든 방**에 `자신의 왼쪽 대각선 위치에 있는 배열방 값`을 더한 형태로 구해보았다. <br>
결과는 다음과 같다.<br>

<img src="https://user-images.githubusercontent.com/62331803/100489069-6c118200-3155-11eb-85c9-0f0d3a423dba.png" width="40%">
<br>

즉, 구한 결과와 테스트 케이스에서 주어진 정답값이 일치하지 않는다는 것을 알 수 있다.<br>
실제 정답인 **260**은 빨간색으로 체크한 `50 + 50 + 100 + 60`을 한 값이다. <br>
여기서 도출할 수 있는 논리는 <br>
현재 위치의 최댓값을 구하기 위해서는 해당 위치의 대각선 왼쪽의 값과 그 값의 왼쪽 값의 최댓값을 현재 값에 더해주는 것이다. <br>
식으로 나타내면 다음과 같다. <br>
`dp[0][j] += max(dp[1][j-1],dp[1][j-2])` <br>

<br> 
**이 논리를 토대로 테스트 케이스를 다시 살펴보자.**<br>

1. 우선 dp배열에는 입력받은 값 `[[50,10,100,20,40],[30,50,70,10,60]]`이 들어있다. 이중 for문을 통해서 각 값을 재연산하는 방식으로 최댓값을 구한다.

2. 우선 점화식 사용 전, 기본적인 값을 세팅해준다. 
- `0번째 열`의 값들은 그대로 두고
- `1번째 열`의 값들은 0번째 열의 대각선 값을 더해주는 형태로 초기화 해준다

3. 이제 `0번째 행`의 `2번째 열`값을 구해보자.

<img src="https://user-images.githubusercontent.com/62331803/100489767-b39a0d00-3159-11eb-9019-c727702ddf36.png" width="40%">
<br>

- 해당 값을 구하기 위해서 고려해야 하는 것은 이미 구한 왼쪽 `빨간 점선 안의 요소`들이다.

<img src="https://user-images.githubusercontent.com/62331803/100489825-26a38380-315a-11eb-8783-d759efc6dfa7.png" width="40%">
<br>

- 서로 맞닿아있는 스티커는 사용할 수 없다는 규칙이 있으므로, `바로 왼쪽 칸`은 고려대상에서 지워진다. 

<img src="https://user-images.githubusercontent.com/62331803/100489981-34a5d400-315b-11eb-9483-4ce2c9a750b7.png" width="40%">
<br>

- 또한 0번째 행 0번째 열(50)보다 1번째 행 1번째 열(100)이 항상 크게 되므로(해당 값을 구할 때 a와 자신의 값을 더한 형태가 되기 때문에), 0번째 행 0번째 열도 고려대상에서 지워진다. 
- 그럼 고려대상은 `30`과 `100`이 남게되고, 이 중에서 더 큰 값을 현재 배열방 값에 더해주게 된다.
   - dp[0][2]의 초기값은 `100`
   - `dp[0][2] = 100 + max(30,100)`
   - 즉, `200` 
 

4. `1번째 행`의 `2번째 열`값도 동일하게 구한다.

<img src="https://user-images.githubusercontent.com/62331803/100490027-7afb3300-315b-11eb-8a20-aac24ff8144b.png" width="40%">
<br>

- 빨간 영역 중 현재 스티커와 인접해 있는 `100`과 `200`을 제외
- `40`에 이미 포함되어 있는 `30`도 제외
- 결과적으로 대각선 왼쪽에 위치한 `40`과 그 왼쪽의 `50`을 비교하여 더 큰 값을 더하기 연산해준다.
   - `70 + max(40,50) = 120`


5. 동일한 방식으로 전체 dp배열을 구하면 최댓값인 `260`을 구할 수 있다.

<img src="https://user-images.githubusercontent.com/62331803/100490077-cdd4ea80-315b-11eb-89fe-8ecd0addf134.png" width="40%">
<br>
<br>

> 코드

```python
import sys
input = sys.stdin.readline
T =int(input())
for _ in range(T):
    n = int(input())
    dp = []
    for _ in range(2):
        dp.append(list(map(int,input().split())))

    if n > 1: 
        dp[0][1] += dp[1][0]
        dp[1][1] += dp[0][0]
    for i in range(2,n):
        dp[0][i] += max(dp[1][i-1],dp[1][i-2])
        dp[1][i] += max(dp[0][i-1],dp[0][i-2])

    print(max(dp[0][-1],dp[1][-1]))
```

