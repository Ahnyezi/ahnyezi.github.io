---
title:  "[DP] 백준 11057 오르막 수 자바"
date: 2021-01-29
categories: ['Ext']
tags: ['DP']
---
<br>

**오르막 수**<br>

<img src="https://user-images.githubusercontent.com/62331803/106342055-c9a38580-62e2-11eb-92fd-b07586b40402.png" width="70%"><br>

- 오르막 수는 수의 자리가 오름차순을 이루는 수이다.
- 인접한 수가 같아도 오름차순으로 친다.
- 수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구해라
- 0으로 시작할 수 있다.
- 1 <= N <= 1000

### 풀이
- 오름차순으로 수열을 구하는 것은 백트래킹으로 간단히 풀 수 있지만, 여기서는 N이 1000까지 갈 수 있기 때문에 백트래킹으로 풀 경우 시간초과가 날 것이다.
- 따라서 각 자리수별로 마지막 숫자가 `0`일 때, `1일 때`, `2일 때`.... `9일 때`의 개수를 세서 규칙을 찾고 DP로 풀어보자.
   - `자리수(N)가 1일때 마지막 숫자가 0일 경우`: 0
   - `자리수(N)가 1일때 마지막 숫자가 1일 경우`: 1
   - `자리수(N)가 1일때 마지막 숫자가 2일 경우`: 2
   - `자리수(N)가 2일때 마지막 숫자가 0일 경우`: 00
   - `자리수(N)가 2일때 마지막 숫자가 1일 경우`: 01, 11
   - `자리수(N)가 2일때 마지막 숫자가 2일 경우`: 02, 12, 22
<br>

> 자릿수별 오르막 개수

|오르막 수의 마지막 숫자|0|1|2|3|4|5|6|7|8|9|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|N = 1|1개|1개|1개|1개|1개|1개|1개|1개|1개|1개|
|N = 2|1개|2개|3개|4개|5개|6개|7개|8개|9개|10개|
|N = 3|1개|3개|6개|10개|15개|21개|28개|36개|45개|55개|
|N = 4|1개|4개|10개|20개|35개|56개|84개|120개|165개|220개|


:point_right: **도출한 규칙**<br>
- 자리수(N)이 `3`일 때 마지막 숫자가 `2`일 경우를 생각해보자.
- 오르막 수는 인접하는 수가 같거나 오름차순이어야 하므로, 마지막 수인 `2`전에 와야하는 숫자는 2와 같거나 2 보다 작은 `2`,  `1`,  `0`이다.
- 따라서 자리수(N)이 `3`일 때 마지막 수가 `2`인 경우에 해당하는 숫자는, 자리수(N)이 2일 때 `2`로 끝나는 숫자(`02,12,22`), `1`로 끝나는 숫자(`01,11`), `0`으로 끝나는 숫자 (`00`)에 `2`를 붙인 수이다. 
   - 자리수 3일  때 `2`로 끝나는 오르막 수 : `(자리수 2일 때 2로 끝나는 수 + '2') 022,122,222`, `(자리수 2일 때 1로 끝나는 수 + '2') 012,112`, `(자리수 2일 때 0으로 끝나는 수 + '2') 002`

**이 규칙으로 점화식을 세우면 다음과 같다.**<br>
- **자리수가 N일 때 i로 끝나는 오르막 수 개수** = `자리수가 N - 1일 때 i로 끝나는 오르막 수 개수` + `자리수가 N - 1일 때 i-1로 끝나는 오르막 수 개수` + .... + `자리수가 N - 1일 때 1로 끝나는 오르막 수 개수` + `자리수가 N - 1일 때 0으로 끝나는 오르막 수 개수`
- 이 때, `자리수가 N-1일 때 i - 1로 끝나는 오르막 수 개수`  ...... `자리수가 N-1일 때 0으로 끝나는 오르막 수의 개수`**의 합**은 **자리수가 N일 때 i-1로 끝나는 오르막 수의 개수와 동일**하다.
   - `N = 2 , i = 2`일 때, N-1은 1, i-1은 1이다.
   - `자리수(N)가 1일때 마지막 숫자가 0일 경우`: 0
   - `자리수(N)가 1일때 마지막 숫자가 1일 경우`: 1
   - `자리수(N)가 2일때 마지막 숫자가 1일 경우`: 01, 11
- 즉, **자리수가 N일 때 i로 끝나는 오르막 수 개수** =  `자리수가 N - 1일 때 i로 끝나는 오르막 수 개수` + `자리수가 N일 때 i-1로 끝나는 오르막 개수`이다.
- `dp[N][i] = dp[N-1][i] + dp[N][i-1](dp[N-1][i-1]+dp[N-1][i-2]+...+dp[N-1][0])`
<br>

**위의 규칙을 토대로 코드를 짜보자.**<br>

<br>
<br>

> 코드

```java
import java.util.Scanner;

public class b11057 {
    static int N;

    static void solution1() {
        if (N == 1) {
            System.out.println(10);
            return;
        }

        int[][] dp = new int[1000][11]; // ' '  + 0 ~ 9
        for (int i = 1; i < 11; i++) {
            dp[0][i] = 1; // 0 부터 9까지
        }

        long sum = 0;
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < 11; j++) {
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % 10_007;// 여기 안해주면 long 범위 넘어가서 음수 나올 수도
                System.out.println(dp[i][j]);
                if (i == N - 1)
                    sum += dp[i][j];
            }
        }

        System.out.println(sum % 10_007);
    }

    // 슬라이딩 윈도우
    static void solution2() {
        if (N == 1) {
            System.out.println(10);
            return;
        }

        int[] dp = new int[10]; 
        for (int i = 0; i < 10; i++) {// i가 0이면 오르막수 개수는 항상 1이다.
            dp[i] = 1;
        }

        long sum = 1;
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < 10; j++) {
                dp[j] = (dp[j - 1] + dp[j]) % 10_007;
                if (i == N - 1) sum += dp[j];
            }
        }
        System.out.println(sum % 10_007);
    }

    // 재귀(Top-down)
    static void solution3() {
        long sum = 0;
        int[] dp = dfs(N);
        for (int num : dp) {
            sum += num;
        }
        System.out.println(sum % 10_007);
    }

    static int[] dfs(int depth) {
        int[] current = new int[10];
        if (depth == 1) {
            for (int i = 0; i < 10; i++) {
                current[i] = 1;
            }
            return current;
        }

        int[] before = dfs(depth - 1);
        current[0] = 1;
        for (int i = 1; i < 10; i++) {
            current[i] = (current[i - 1] + before[i]) % 10_007;
        }

        return current;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        solution3();
    }
}

```
<br>


<img src="https://user-images.githubusercontent.com/62331803/106343228-b0510800-62e7-11eb-9ab6-3074912bfc20.png" width="70%"><br>

1. solution2 : 슬라이딩 윈도우
2. solution1 : 일반풀이

<br><br>
   




