---
title:  "[Operating System ②] 운영체제 개념 잡기 "
date: 2020-11-23
categories: ['OS']
tags: ['OS']
---



[Operating System ②] 운영체제 개념 잡기

##### HPC Lab 김덕수 교수님의 운영체제 강의를 정리한 내용입니다. :+1: 
[강의링크](https://www.youtube.com/watch?v=nxl_cUd55Ag&list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN&index=2)

<br>

### 목차

:point_right: **운영체제는 왜 필요한가?** <br>

1. [운영체제란?](#운영체제란)
2. [운영체제는 어떤 부분을 도와주는가?](#운영체제는-어떤-부분을-도와주는가)
3. [컴퓨터 시스템 구성도](#컴퓨터-시스템-구성도)

:point_right: **운영체제는 어떻게 분류하는가?**  <br>

1. [몇 명이 사용하는지에 따른 분류](#몇-명이-사용하는가)
    - 단일 사용자
    - 다중 사용자
2. [동시에 여러 프로그램(프로세스)을 실행시킬 수 있는지에 따른 분류](#동시에-여러-프로그램을-실행시킬-수-있는가)
    - 단일 작업
    - 다중 작업
3. [프로그램을 수행하는 방식이 어떠한지에 따른 분류](#프로그램을-수행하는-방식이-어떠한가)
    - 순차처리
    - 일괄처리
    - 시분할
    - 퍼스널 컴퓨팅
    - 병렬처리
    - 분산처리
    - 실시간

:point_right: **운영체제의 내부는 어떻게 구성되어 있는가?** <br>
1. [단일구조 운영체제](#단일-구조-운영체제)
2. [계층구조 운영체제](#계층-구조-운영체제)
3. [마이크로 커널구조](#마이크로-커널-구조)

:point_right: **운영체제는 어떤 작업을 수행하는가?** <br>
1. [프로세스(실행 중인 프로그램) 관리](#프로세스-관리)
2. [프로세서(CPU) 관리](#프로세서-관리)
3. [메모리 관리](#메모리-관리)
4. [파일 관리](#파일-관리)
5. [주변장치 입출력 관리](#주변장치-입출력-관리)


<br><br>

## :pushpin: 운영체제는 왜 필요한가?

### 운영체제란?
**컴퓨터 하드웨어를 효율적으로 관리해서 사용자와 응용 프로그램에게 서비스를 제공하는 시스템** <br>

즉, 컴퓨터 자원들을 관리하며 사람들이 컴퓨터를 좀 더 '잘' 사용할 수 있게 도와준다. 

<br>

### 운영체제는 어떤 부분을 도와주는가? 

<img src="https://user-images.githubusercontent.com/62331803/99939784-3879d500-2dae-11eb-877e-791fa9a42c93.png" width="70%">

#### 운영체제가 수행하는 역할은 크게 4가지

1. UI => 사용자가 컴퓨터를 편리하게 사용하게 한다.
- CUI : 과거에 사용되던 문자 기반의 인터페이스 
- GUI : 현재 많이 쓰이는 그림 기반의 인터페이스 
- EUCI : 특별한 목적을 위해 만들어진 인터페이스
   - (예) mp3에 특화된 UI 

2. 자원관리 => 컴퓨터 내부의 리소스를 통제하여 효율적으로 컴퓨터를 사용할 수 있도록 한다. 
- HW
- SW

3. 프로세스(실행주체)와 스레드(가벼운 프로세스) 관리

4. 시스템 보호
- 사용자가 불법적인 형태로 시스템 사용하려고 하는 경우 보호하는 역할 수행

<br>

### 컴퓨터 시스템 구성도

> OS는 크게 Kernel과 System Call Interface로 구성된다. <br>

<img src="https://user-images.githubusercontent.com/62331803/99940094-db325380-2dae-11eb-9b72-5d07713cae21.png" width="70%">

-  커널: 운영체제의 핵심을 모아놓은 것
 - 시스템 콜 인터페이스:  커널이 제공하는 기능 중, 사용자가 접근 가능한 기능을 모아놓은 것 (통로 역할)
   - 사용자가 커널을 직접 access하게 되면, OS가 HW를 제어하는 데 문제를 일으킬 수 있다.
   - 따라서 커널에 access를 원하는 경우, System call interface를 통해 OS 커널에 접근할 수 있도록 요청을 한다. 
  
  <br>

> 위에서 부터, 사용자들 / 시스템 콜 인터페이스 / 커널  <br>

<img src="https://user-images.githubusercontent.com/62331803/99940474-8d6a1b00-2daf-11eb-82a9-7d81222c6266.png" width="70%">

<br><br>


## :pushpin: 운영체제는 어떤 종류가 있는가?

**분류 방법 크게 3가지**

<img src="https://user-images.githubusercontent.com/62331803/99940753-26993180-2db0-11eb-9963-5b9541281e93.png" width="80%">

1. `동시 사용자 수` : 한 명이 사용하는가 여러 명이 사용하는가?
2. `동시 실행 프로세스 수`: 동시에 여러 프로그램을 수행할 수 있는가?
3. `작업 수행 방식(사용자가 느끼는 사용환경)`: 프로그램을 수행하는 방식이 어떠한가?

<br>

### 몇 명이 사용하는가?

<img src="https://user-images.githubusercontent.com/62331803/99940852-5ba58400-2db0-11eb-9f76-36945ae0594f.png" width="80%">

1. 단일 사용자 :  한 순간에 한 명만 사용할 수 있는 OS
- 비교적 간단하게 만들 수 있다
- 자원관리 쉽다
- 시스템 보호 쉽다

2. 다중 사용자 : 한 순간에 여러 명이 사용할 수 있는 OS
- 단일 사용자 시스템에 비해 복잡하다.
   - 서버, 슈퍼컴퓨터와 같은 클러스터 등은 다중 사용자 시스템으로 분류
- 자원의 소유권 문제가 존재한다.
- 멀티 태스킹이 가능해야 한다 =>  여러개의 프로그램을 돌릴 수 있어야 한다 

<br>

### 동시에 여러 프로그램을 실행시킬 수 있는가?

<img src="https://user-images.githubusercontent.com/62331803/99941549-8c39ed80-2db1-11eb-8f1b-b861b4eb6e9e.png" width="80%">


1. 단일작업 : 하나의 프로그램(프로세스)만 실행 가능
- 하나를 마친 후에 다른 프로그램 실행해야 한다.
   - 요즘 찾아보기 힘듦
   -(예)  MS DOS => 실행된 프로그램 종료될 때까지 기다려야 함

2. 다중작업 : 동시에 여러개의 프로그램(프로세스) 실행 가능
- 창 여러개 띄워놓고 작업할 수 있다.
   - 우리에게 익숙한 형태
- 단일 작업 시스템보다  구조가 복잡하다

<br>

### 프로그램을 수행하는 방식이 어떠한가?

**운영체제 발전 역사와 관련 있음**

1-1. `순차처리` : 가장 원시적인 처리 방법<br>
1-2. `일괄처리(Batch processing)` : 모아뒀다가 한꺼번에 처리<br>
1-3. `시분할(Time-sharing)` : 짧은 시간단위로 각 프로그램을 돌아가며 처리 <br>
<br>

2-1.  `퍼스널 컴퓨팅` : 단말기를 사용하지 않고 개인용 OS를 사용<br>
2-2.  `병렬처리` : 컴퓨터 내에 여러개의 CPU를 두어 성능을 향상시킨 방식<br>
2-3.  `분산처리(Distributed processing)` : 여러 대의 컴퓨터를 연결하여 성능을 향상시킨 방식 <br>
<br>

3-1. `실시간(Real-time)` : 처리에 시간 제한을 둔 방식<br>

<br><br>

### (1) 작업 수행 방식1 - 순차 처리

<img src="https://user-images.githubusercontent.com/62331803/99942420-fbfca800-2db2-11eb-93c3-247ccbafa630.png" width="80%">

- 운영체제가 하는 역할 모두를 사용자가 직접 수행
    - 프로세스로 어떤 프로그램을 수행할지
    - 해당 프로그램의 어느 지점을 수행할지(PC)
    - 어디서 읽어올지
- 실행할 프로그램 마다 환경을 다시 설정
    -오랜 준비 시간 소요

<br>

###  (1) 작업 수행 방식2 - 배치시스템

> 순차처리방식이 준비 시간 길다는 문제를 해소<br>

<img src="https://user-images.githubusercontent.com/62331803/99942659-5dbd1200-2db3-11eb-9660-5775a9710d59.png" width="80%">

   - 실행할 프로그램들을 모아뒀다가 한꺼번에 처리
   - 프로그램 사이사이 준비시간을 줄일 수 있음
   - (예) C 파일 완료 후 Java파일 완료 후 Python 파일 실행

<br>

> 배치시스템의 장단점 <br>

<img src="https://user-images.githubusercontent.com/62331803/99942958-d7550000-2db3-11eb-80b2-1ab194f7508c.png" width="80%">

- 시스템이 처리하기 편한 방법
    - 모아둿다가 한번에 처리할 수 있으므로
     - 쓰루풋 좋음
- 하지만, 결과 언제 받아볼 지 알 수 없음

<br><br>

###  (1) 작업 수행 방식3 - 시분할시스템

<img src="https://user-images.githubusercontent.com/62331803/99943277-63ffbe00-2db4-11eb-8d12-50348841cea8.png" width="80%">

- 시간을 나누어서 사용하는 방식(요즘 사용되는 시스템 방식)
   - 과거: A완료 =>  B완료 => C완료
	- TS : A(1) => B(1) => C(1) => A(2) .... 
- 여러 사용자가 자원을 동시에 사용
   - 이 시기에 파일 시스템과 가상 메모리가 등장하고 해당 기능들을 관리하기 시작
- 사용자 지향적
   - `대화형 시스템`: 한 작업이 끝날 때까지 기다리는 것이 아니라,  일정시간 지나면 반응 하기 때문에 
   - `단말기 사용한 접근` : 컴퓨터 내부에 HW가 있는 형태가 아니라. 단말기를 사용해서 결과화면을 출력하고, 키보드로 입력된 내용을 전달해주는 방식이었음

<br>

> 시분할 시스템 구조 <br>

<img src="https://user-images.githubusercontent.com/62331803/99943429-a45f3c00-2db4-11eb-8bac-89ac5a7a9968.png" width="80%">

- `초록`: 실제 연산하는 곳
- `분홍`: 사용자들이 단말기로 요청을 보내고, 결과를 받아보는 곳

<br>

> 시분할 시스템의 장단점 <br>

- 항상 일정 시간 내에 반응하기 때문에, 사용자 입장에서는 좋음
- 여러 개의 프로세스가 프로세서를 나눠서 씀
    -  유휴 시간 감소됨
- 하지만, 통신으로 인한 문제점
    - 단말기를 통해 접속하기 때문에 통신에 따르는 비용 증가
    - 통신에 따르는 보안 문제 등장
- 너무 많은 사람들이 접속 할 경우 부하가 커지고 느려진다.

<br><br>


###  (2) 작업 수행 방식1 - 퍼스널 컴퓨팅

<img src="https://user-images.githubusercontent.com/62331803/99944072-a37ada00-2db5-11eb-8c16-6221ab231c98.png" width="80%">


**단말기 쓰는거 너무 느리니까 나 혼자만 쓰고 싶다**

- 단말기를 사용하는 기존방식과 추구하는 목표 다름 
    - 과거의 목표 cpu활용률 높이기(컴터를 쉬지않고 돌리는 것)
    - 개인화되면서, 사용자가 얼마나 편리하게 시스템을 사용하느냐가 중요해짐
- 한 사람이 쓰기 때문에 OS가 단순해짐
   - 그대신 사용자 편리성 높여주는 쪽으로 발전
- 혼자쓰니까 빠르지만, 비싼거 사기 힘드니까 성능 낮음

<br>

###  (2) 작업 수행 방식2 - 병렬 처리 시스템

<img src="https://user-images.githubusercontent.com/62331803/99944355-1421f680-2db6-11eb-9929-1e8971a889cf.png" width="80%">


**성능 구리다. 컴퓨터 안에 CPU 여러개 박아서 성능 높이자**

- 하나의 시스템에 여러 개의 프로세서를 사용하는 방식
- Tightly-coupled system의 형태(자원과 꽉 묶여있다)
   - CPU는 여러갠데 기타 자원은 공유해서 사용하는 형태 
- 사용 목적
   - 신뢰성: CPU 1개 고장나도 다른 애들이 대신 일 해줄 수 있음
- 하지만, CPU가 여러개니까 그들 사이에 관계나 역할을 나눌 필요성 생김

<br>

### (2) 작업 수행 방식3 - 분산 처리 시스템(병렬 처리의 한 분야)

> Tightly-coupled 방식으로 CPU 100개의 성능을 내고 싶다? <br>

하나의 컴퓨터에 CPU 100개 심을 수 없음. 공간적/시스템적 한계 <br>
즉, 확장에 제약이 존재 <br>
**그럼, 내부에 프로세서 여러개를 사용하는 방식이 아니라, 컴퓨터 여러대를 붙여서 성능을 높이자**

> 분산처리 시스템 : LAN(네트워크)를 사용해서 컴퓨터 여러 대를 묶은 병렬처리 시스템  <br>

<img src="https://user-images.githubusercontent.com/62331803/99944623-8bf02100-2db6-11eb-80e6-8bef784a9ba0.png" width="80%">

<br>

> 물리적인 통신망을 이용해 연결한 형태 <br>

<img src="https://user-images.githubusercontent.com/62331803/99944822-e0939c00-2db6-11eb-9440-9fb338ef481f.png" width="80%">

- 각각의 노드(붙어있는 컴터)들은 자기만의 OS를 가짐
    - 이것들을 묶어서 관리해주는 분산운영체제가 존재
-  클러스터 시스템(슈퍼컴), 클라이언트-서버 시스템 등...

> 분산처리 시스템의 장단점 <br>

<img src="https://user-images.githubusercontent.com/62331803/99944926-0e78e080-2db7-11eb-98a2-57805fec4087.png" width="80%">

- 장점
   - 신뢰성
- 단점
   - 구축과 관리 힘들다

<br><br>

### (3) 작업 수행 방식- 실시간 시스템

<img src="https://user-images.githubusercontent.com/62331803/99945160-7d563980-2db7-11eb-8375-8b606d219da0.png" width="80%">


- 작업 처리에 제한 시간을 갖는 시스템
   - 작업 요청하면 적어도 이때까지는 요청 받아야 한다
- 하드 리얼타임 (예시)
   - 원자력 관리 시스템, 군에서 사용하는 무기 관리
   - 온도체크해서 1초마다 알려주는 시스템
   - 1초만에 온도체크 실패? 온도 기준치 이상으로 올라갈 수 있고, 발전소 위험에 처할 가능성 있음
   - 즉, 시간안에 결과를 보장하지 못하면 큰 문제가 발생하는 시스템
- 소프트 리얼타임 (예시)
   - 유튜브의 동영상
   - 기본적으로 1초에 30장의 그림을  만들어 내야 함
   - 하지만, 네트워크 느리거나 문제가 발생해서 흐릿하게 나오는 경우

<br><br>



## :pushpin: 운영체제의 내부는 어떻게 구성되어 있는가?

<img src="https://user-images.githubusercontent.com/62331803/99945241-a1b21600-2db7-11eb-84b0-a62fa921e8bd.png" width="80%">


**크게 두가지로 구성되어 있다**

1. 커널 -> 알맹이라는 의미
- OS의 핵심 부분.
- 즉, 가장 빈번하게 사용되는 부분을 모아놓은 것
- 예) 프로세서 관리, 메모리 관리 등...  
- 계속 써야 하기 때문에 메모리에 '항상' 올라가 있음

2. 유틸리티 -> 커널을 제외한 나머지 부분
- 대표적으로 ui나 자주사용하지 않는 부분
- 가끔씩 쓰기 때문에 필요한 순가 메모리에 올려서 사용함

<br>

> OS는 컴퓨팅 리소스를  관리한다 <br>

<img src="https://user-images.githubusercontent.com/62331803/99945298-be4e4e00-2db7-11eb-98ec-f32a0b639842.png" width="80%">

<br><br>


### 단일 구조 운영체제

<img src="https://user-images.githubusercontent.com/62331803/99945539-23a23f00-2db8-11eb-9405-e9561cb2607d.png" width="80%">

- 운영체제의 기능을 하나의 거대한 커널, 즉 단일 구조로 모아놓은 것
   - 프로그램으로 예를 들면 메인 안에 모든 것들이 다 짜져있는 형태
- 장: 커널 내의 각 기능들 사이에 모듈간에 직접 통신 가능. 빠르게 할 수 있음
- 단: 기능이 추가될 수록 사이즈 너무 커짐. 버그 발생할 경우 유지보수 힘듦
- 또 악성코드 침입한다면 걔가 커널 전체기능 다 건드려서 영향 줄 수 있음

<br>

### 계층 구조 운영체제

<img src="https://user-images.githubusercontent.com/62331803/99945640-4fbdc000-2db8-11eb-9397-0b130e35bbed.png" width="80%">

- `단일구조 운영체제`의 문제를 해결하기 위해 계층별로 묶자 => 현대 운영체제의 형태
- 모듈화 해서 각 기능에만 집중 
    - 설계와 구현, 문제 생길 때 유지보수 단순화
- 하지만, 여러 계층을 거쳐서 기능이 실행되므로 성능 떨어질 수 있음

<br>


### 마이크로 커널 구조

<img src="https://user-images.githubusercontent.com/62331803/99945697-6c59f800-2db8-11eb-9643-2c651720c653.png" width="80%">

- 커널이 점점 커지니 문제가 된다.
- 커널에 필수 기능만 담고, 나머지 응용프로그램처럼 사용자 영역에서 조작하자
- 메모리 관리, 프로세스관리, 통신관리만 

<br><br>

## :pushpin: 운영체제는 어떤 작업을 수행하는가?

### OS의 기능은 '관리'에 있다
**다양한 HW, SW리소스를 관리**

<img src="https://user-images.githubusercontent.com/62331803/99945819-af1bd000-2db8-11eb-99c5-348e336dbceb.png" width="80%">

<br>

### 프로세스 관리

<img src="https://user-images.githubusercontent.com/62331803/99946018-0457e180-2db9-11eb-96a3-dd31d9c03152.png" width="80%">

- `프로세스` : 실행 중인 프로그램
   - 프로세서와 구별해라
- 여러개의 프로세스가 하나의 자원을 동시에 쓰려고 할 때 중재하는 역할 함
    - 교착 상태, 데드락
- 정보 관리를 위한 PCB를 가지고 있다

<br>


### 프로세서 관리

<img src="https://user-images.githubusercontent.com/62331803/99946100-25b8cd80-2db9-11eb-8323-e14e48dad81a.png" width="80%">

- 누구한테 얼마만큼 줄 것인가
- 스케줄링 등

<br>

### 메모리 관리

<img src="https://user-images.githubusercontent.com/62331803/99946311-80522980-2db9-11eb-8b68-5286c9ead395.png" width="80%">

- 일반적으로 `Memory` ==  `주기억장치(메인보드에 꽂아쓰는 DRAM)` 
- 여러 개의 프로세스가 메모리를 동시에 사용하기 때문에, 어케 할당하고 회수하는지를 결정
- 불법적인 사용 막기

<br>

### 파일 관리

**대표적인 SW 리소스인 파일을 관리하는 역할도 수행**

<img src="https://user-images.githubusercontent.com/62331803/99946392-a37cd900-2db9-11eb-80eb-98be8a886131.png" width="80%">

<br>

### 주변장치 입출력 관리
**프로세서(CPU)가 직접 입출력할 수 없기 때문에, OS가 중간에서 관리**

<img src="https://user-images.githubusercontent.com/62331803/99946501-ceffc380-2db9-11eb-9572-2da862c1ae0c.png" width="80%">

<br>

> '프로세서(CPU)'가 커널에 요청을 하면 'OS'가 '입출력장치'와 통신 <br>

<img src="https://user-images.githubusercontent.com/62331803/99946628-02425280-2dba-11eb-9d00-f1a4ee2846c0.png" width="80%">

<br>

'
### 역할6 그 외에 관리하는 리소스들

<img src="https://user-images.githubusercontent.com/62331803/99946741-3b7ac280-2dba-11eb-9cfd-9f9abe073947.png" width="80%">

<br>




